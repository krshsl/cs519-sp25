--- /dev/null	2025-04-12 11:46:12.832000561 -0600
+++ ../project2/linux-5.15.0/mm/my_extent.c	2025-04-12 12:10:41.360979219 -0600
@@ -0,0 +1,288 @@
+#include "linux/kern_levels.h"
+#include "linux/list.h"
+#include <linux/kernel.h>
+#include <linux/syscalls.h>
+#include <linux/my_extent.h>
+#include <linux/printk.h>
+
+pid_t do_extents_pid = -1;
+EXPORT_SYMBOL(do_extents_pid);
+
+// my rb root tree for page extns
+struct rb_root expg_root = RB_ROOT;
+size_t pt_count;
+size_t total_extents;
+
+#define LOG_MY_FUNCS
+
+#ifdef LOG_MY_FUNCS
+    #define IS_EMPTY_ARGS(dummy, ...) ( sizeof( (char[]){#__VA_ARGS__} ) == 1 )
+
+    #define LOG_FUNCS(level, ...) do { \
+        printk(level "%s:%d", __func__, __LINE__); \
+        if (!IS_EMPTY_ARGS(__VA_ARGS__)) pr_cont("::"); \
+        pr_cont(__VA_ARGS__); \
+        pr_cont("\n"); \
+    } while(0)
+
+    #define LPRINTK(fmt, ...) printk(fmt, ##__VA_ARGS__)
+#else
+    #define LOG_FUNCS(level, ...)
+    #define LPRINTK(...)
+#endif
+
+void free_pg_list(struct list_head *head) {
+    struct list_extns *curr = NULL;
+    struct list_extns *node = NULL;
+
+    LOG_FUNCS(KERN_ALERT);
+    list_for_each_entry_safe(curr, node, head, pg_list) {
+        LPRINTK(KERN_CONT "%lu:%llu,", curr->vma, curr->pte);
+        list_del(&curr->pg_list);
+        kfree(curr);
+    }
+    LPRINTK(KERN_CONT "\n");
+}
+
+void free_pg_tree(void) {
+    struct rb_node *root;
+    int iter = 0;
+
+    LOG_FUNCS(KERN_DEBUG);
+    while ((root = rb_first(&expg_root))) {
+        struct rb_extns *node = rb_entry(root, struct rb_extns, pg_tree);
+        LPRINTK(KERN_DEBUG "%d:%zu::", iter++, node->count);
+        rb_erase(&node->pg_tree, &expg_root);
+        free_pg_list(&node->p_node);
+        kfree(node);
+    }
+}
+
+void print_pg_tree(void) {
+    struct rb_extns *tmp, *node;
+    struct list_extns *curr;
+    int iter = 0;
+
+    rbtree_postorder_for_each_entry_safe(node, tmp, &expg_root, pg_tree) {
+        LPRINTK(KERN_DEBUG "%s:%d", __func__, __LINE__);
+        LPRINTK(KERN_CONT "%d:%zu::", iter++, node->count);
+        list_for_each_entry(curr, &node->p_node, pg_list) {
+            LPRINTK(KERN_CONT "%lu:%llu,", curr->vma, curr->pte);
+        }
+        LPRINTK(KERN_CONT "\n");
+    }
+}
+
+int compare_pg(struct rb_node **cursor, struct rb_extns *node, unsigned long vma) {
+    struct list_extns *head = list_first_entry_or_null(&node->p_node, struct list_extns, pg_list);
+    struct list_extns *tail = list_last_entry(&node->p_node, struct list_extns, pg_list);
+
+    // LOG_FUNCS(KERN_DEBUG, "%lu", vma);
+    if (head == NULL) {
+        LPRINTK(KERN_CRIT "%s:%d::Invalid entry while adding vma %lu", __func__, __LINE__, vma);
+        return -1; // invalid entry!!
+    }
+
+    if (head->vma > vma)
+        *cursor = (*cursor)->rb_left;
+    else if (tail->vma < vma)
+        *cursor = (*cursor)->rb_right;
+    else
+        return 0;
+
+    return 1;
+}
+
+struct rb_extns *pg_search(struct rb_root *root, unsigned long vma) {
+    struct rb_node *cursor = root->rb_node;
+    int result;
+
+    // LOG_FUNCS(KERN_DEBUG, "%lu", vma);
+    while(cursor) {
+        struct rb_extns *node = container_of(cursor, struct rb_extns, pg_tree);
+        result = compare_pg(&cursor, node, vma);
+
+        if (result == -1)
+            return NULL;
+        else if (result == 0)
+            return node;
+    }
+    return NULL;
+}
+
+int pg_insert(struct rb_root *root, struct rb_extns *data) {
+    struct list_extns *head = list_first_entry_or_null(&data->p_node, struct list_extns, pg_list);
+    struct rb_node **cursor = &(root->rb_node);
+    struct rb_node *parent = NULL;
+    int result;
+
+    // LOG_FUNCS(KERN_DEBUG);
+    if (head == NULL) return 0;
+
+    // LOG_FUNCS(KERN_DEBUG, "%lu:%llu", head->vma, head->pte);
+    while(*cursor) {
+        struct rb_extns *node = container_of(*cursor, struct rb_extns, pg_tree);
+        parent = *cursor;
+
+        result = compare_pg(cursor, node, head->vma);
+        if (result != 1) return 0;
+    }
+
+    rb_link_node(&data->pg_tree, parent, cursor);
+    rb_insert_color(&data->pg_tree, root);
+    // LOG_FUNCS(KERN_DEBUG, "%lu:%llu", head->vma, head->pte);
+    return 1;
+}
+
+struct list_extns *create_extn(unsigned long vma, unsigned long long pte) {
+    struct list_extns *list_node = kmalloc(sizeof(struct list_extns), GFP_KERNEL);
+    LOG_FUNCS(KERN_DEBUG, "%lu:%llu", vma, pte);
+    INIT_LIST_HEAD(&list_node->pg_list);
+    list_node->vma = vma;
+    list_node->pte = pte;
+    total_extents++;
+    return list_node;
+}
+
+void update_pg_extns(struct rb_extns *rb_node, unsigned long vma, unsigned long long pte) {
+    struct list_head *head = &rb_node->p_node;
+    struct list_extns *node = list_first_entry(head, struct list_extns, pg_list);
+    struct list_head *pos = NULL;
+
+    LOG_FUNCS(KERN_DEBUG, "%lu:%llu", vma, pte);
+    list_for_each(pos, head) {
+        node = list_entry(pos, struct list_extns, pg_list);
+        if (node->vma != vma) continue;
+        node->vma = vma;
+        return;
+    }
+}
+
+void create_extents(struct list_extns *new_node) {
+    struct rb_extns *rb_node = kmalloc(sizeof(struct rb_extns), GFP_KERNEL);
+
+    LOG_FUNCS(KERN_DEBUG, "%lu:%llu", new_node->vma, new_node->pte);
+    rb_node->count = 1;
+    INIT_LIST_HEAD(&rb_node->p_node);
+    list_add(&new_node->pg_list, &rb_node->p_node);
+    pg_insert(&expg_root, rb_node);
+    pt_count++;
+}
+
+struct rb_extns *should_join_front(unsigned long vma, unsigned long long pte) {
+    struct rb_extns *rb_node = NULL;
+    struct list_extns *node = NULL;
+
+    LOG_FUNCS(KERN_DEBUG, "%lu:%llu", vma, pte);
+    vma += PAGE_SIZE;
+    pte += PAGE_SIZE;
+    rb_node = pg_search(&expg_root, vma);
+    if (rb_node == NULL) {
+        return NULL;
+    }
+
+    LOG_FUNCS(KERN_DEBUG, "%lu:%llu", vma, pte);
+    node = list_first_entry(&rb_node->p_node, struct list_extns, pg_list);
+    if (node->vma == vma && node->pte == pte) {
+        LOG_FUNCS(KERN_DEBUG, "%lu:%llu", node->vma, node->pte);
+        return rb_node;
+    }
+
+    return NULL;
+}
+
+struct rb_extns *should_join_back(unsigned long vma, unsigned long long pte) {
+    struct rb_extns *rb_node = NULL;
+    struct list_extns *node = NULL;
+
+    LOG_FUNCS(KERN_DEBUG, "%lu:%llu", vma, pte);
+    vma -= PAGE_SIZE;
+    pte -= PAGE_SIZE;
+    rb_node = pg_search(&expg_root, vma);
+    if (rb_node == NULL) {
+        return NULL;
+    }
+
+    LOG_FUNCS(KERN_DEBUG, "%lu:%llu", vma, pte);
+    node = list_last_entry(&rb_node->p_node, struct list_extns, pg_list);
+    if (node->vma == vma && node->pte == pte) {
+        LOG_FUNCS(KERN_DEBUG, "%lu:%llu", node->vma, node->pte);
+        return rb_node;
+    }
+
+    return NULL;
+}
+
+void add_extents(unsigned long vma, unsigned long long pte) {
+    struct list_extns *new_node = NULL;
+    struct rb_extns *front = NULL;
+    struct rb_extns *back = NULL;
+
+    LOG_FUNCS(KERN_DEBUG, "%lu:%llu", vma, pte);
+    front = should_join_front(vma, pte);
+    back = should_join_back(vma, pte);
+    new_node = create_extn(vma, pte);
+
+    if (front) {
+        LOG_FUNCS(KERN_DEBUG, "list_add::%lu:%llu", vma, pte);
+        list_add(&new_node->pg_list, &front->p_node); // add to the front: head->next is now node
+        front->count++;
+
+        if (back) {
+            LOG_FUNCS(KERN_DEBUG, "list_splice::%lu:%llu", vma, pte);
+            list_splice(&front->p_node, back->p_node.prev); // join front to end of back
+            back->count += front->count;
+
+            // front has been removed, so better to remove this
+            rb_erase(&front->pg_tree, &expg_root);
+            kfree(front);
+            pt_count--;
+        }
+    } else if (back) {
+        LOG_FUNCS(KERN_DEBUG, "list_add_tail::%lu:%llu", vma, pte);
+        list_add_tail(&new_node->pg_list, &back->p_node); // add to the rear: head->prev is now node
+    } else {
+        LOG_FUNCS(KERN_DEBUG, "create_extents::%lu:%llu", vma, pte);
+        create_extents(new_node);
+    }
+}
+
+void handle_extents(unsigned long vma, unsigned long long pte) {
+    struct rb_extns *node = NULL;
+    pid_t pid = task_pid_nr(current);
+
+    if (pid ==  do_extents_pid) {
+        LOG_FUNCS(KERN_DEBUG, "%lu:%llu", vma, pte);
+
+        node = pg_search(&expg_root, vma);
+        if (node)
+            update_pg_extns(node, vma, pte);
+        else
+            add_extents(vma, pte);
+    }
+}
+EXPORT_SYMBOL(handle_extents);
+
+SYSCALL_DEFINE0(enable_extents)
+{
+    pid_t pid = task_pid_nr(current);
+
+    LOG_FUNCS(KERN_DEBUG, "%d", pid);
+    do_extents_pid = pid;
+    total_extents = pt_count = 0;
+    return 0;
+}
+
+SYSCALL_DEFINE0(disable_extents)
+{
+    pid_t pid = task_pid_nr(current);
+    LOG_FUNCS(KERN_ALERT, "%d had %zu extents and %zu pages", pid, pt_count, total_extents);
+
+    if (pid == do_extents_pid) {
+        do_extents_pid = -1;
+        total_extents = pt_count = 0;
+        print_pg_tree();
+        free_pg_tree();
+    }
+    return 0;
+}
