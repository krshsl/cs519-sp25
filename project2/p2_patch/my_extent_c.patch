--- /dev/null	2025-04-12 22:31:40.536000551 -0600
+++ ../project2/linux-5.15.0/mm/my_extent.c	2025-04-12 22:50:56.244363154 -0600
@@ -0,0 +1,349 @@
+#include <linux/kernel.h>
+#include <linux/syscalls.h>
+#include <linux/my_extent.h>
+#include <linux/printk.h>
+
+pid_t do_extents_pid = -1;
+EXPORT_SYMBOL(do_extents_pid);
+
+// my rb root tree for page extns
+struct rb_root expg_root = RB_ROOT;
+atomic_t pt_count;
+atomic_t total_extents;
+
+raw_spinlock_t extents_lock;
+DEFINE_RAW_SPINLOCK(extents_lock);
+
+// #define LOG_MY_FUNCS
+
+#ifdef LOG_MY_FUNCS
+    #define IS_EMPTY_ARGS(dummy, ...) ( sizeof( (char[]){#__VA_ARGS__} ) == 1 )
+
+    #define LOG_FUNCS(level, ...) do { \
+        printk(level "%s:%d", __func__, __LINE__); \
+        if (!IS_EMPTY_ARGS(__VA_ARGS__)) pr_cont("::"); \
+        pr_cont(__VA_ARGS__); \
+        pr_cont("\n"); \
+    } while(0)
+
+    #define LPRINTK(fmt, ...) printk(fmt, ##__VA_ARGS__)
+#else
+    #define LOG_FUNCS(level, ...)
+    #define LPRINTK(...)
+#endif
+
+void free_pg_list(struct list_head *head) {
+    struct list_extns *curr = NULL;
+    struct list_extns *node = NULL;
+
+    // LPRINTK(KERN_DEBUG "%s:%d::", __func__, __LINE__);
+    list_for_each_entry_safe(curr, node, head, pg_list) {
+        // LPRINTK(KERN_CONT "%lu:%llu,", curr->vma, curr->pte);
+        list_del(&curr->pg_list);
+        kfree(curr);
+    }
+    // LPRINTK(KERN_CONT "\n");
+}
+
+void free_pg_tree(void) {
+    struct rb_node *root;
+    // int iter = 0;
+    // LOG_FUNCS(KERN_DEBUG);
+    while ((root = rb_first(&expg_root))) {
+        struct rb_extns *node = rb_entry(root, struct rb_extns, pg_tree);
+        // LPRINTK(KERN_DEBUG "%d:%zu::", iter++, node->count);
+        rb_erase(&node->pg_tree, &expg_root);
+        free_pg_list(&node->p_node);
+        kfree(node);
+    }
+}
+
+void print_pg_tree(void) {
+    struct rb_extns *tmp, *node;
+    struct list_extns *curr;
+    int iter = 0;
+
+    rbtree_postorder_for_each_entry_safe(node, tmp, &expg_root, pg_tree) {
+        LPRINTK(KERN_DEBUG "%s:%d::", __func__, __LINE__);
+        LPRINTK(KERN_CONT "%d:%zu::", iter++, node->count);
+        list_for_each_entry(curr, &node->p_node, pg_list) {
+            LPRINTK(KERN_CONT "%lu:%llu,", curr->vma, curr->pte);
+        }
+        LPRINTK(KERN_CONT "\n");
+    }
+}
+
+int compare_pg(struct rb_node *cursor , unsigned long vma) {
+    struct rb_extns *node = container_of(cursor, struct rb_extns, pg_tree);
+    struct list_extns *head = list_first_entry(&node->p_node, struct list_extns, pg_list);
+    struct list_extns *tail = list_last_entry(&node->p_node, struct list_extns, pg_list);
+
+    // LOG_FUNCS(KERN_DEBUG, "%lu::%lu::%lu", vma, head->vma, tail->vma);
+    if (head->vma > vma)
+        return -1; //  lesser than smallest value
+    else if (tail->vma < vma)
+        return 1; // greater than biggest value
+    else
+        return 0; // can be found somewhere inside
+}
+
+struct rb_extns *pg_search(struct rb_root *root, unsigned long vma) {
+    struct rb_node *cursor = root->rb_node;
+    struct rb_extns *node = NULL;
+    int result;
+
+    // LOG_FUNCS(KERN_DEBUG, "%lu", vma);
+    raw_spin_lock(&extents_lock);
+    while(cursor) {
+        result = compare_pg(cursor, vma);
+
+        if (result == -1)
+            cursor = cursor->rb_left;
+        else if(result == 1)
+            cursor = cursor->rb_left;
+        else {
+            node = container_of(cursor, struct rb_extns, pg_tree);
+            goto exit;
+        }
+    }
+
+    exit:
+    raw_spin_unlock(&extents_lock);
+    return node;
+}
+
+void pg_insert(struct rb_extns *data) {
+    struct list_extns *head = list_first_entry(&data->p_node, struct list_extns, pg_list);
+    struct rb_node **cursor = &expg_root.rb_node;
+    struct rb_node *parent = NULL;
+    int result;
+
+    // LOG_FUNCS(KERN_DEBUG, "%lu:%llu", head->vma, head->pte);
+    raw_spin_lock(&extents_lock);
+    while(*cursor) {
+        parent = *cursor;
+        result = compare_pg(*cursor, head->vma);
+
+        if (result == -1)
+            cursor = &((*cursor)->rb_left);
+        else if(result == 1)
+            cursor = &((*cursor)->rb_left);
+        else {
+            LOG_FUNCS(KERN_CRIT, "failing for some reason... %lu:%llu", head->vma, head->pte);
+            goto exit;
+        }
+    }
+
+    rb_link_node(&data->pg_tree, parent, cursor);
+    rb_insert_color(&data->pg_tree, &expg_root);
+
+    exit:
+    raw_spin_unlock(&extents_lock);
+    // LOG_FUNCS(KERN_DEBUG, "%lu:%llu", head->vma, head->pte);
+}
+
+struct list_extns *create_extn(unsigned long vma, unsigned long long pte) {
+    struct list_extns *list_node = kmalloc(sizeof(struct list_extns), GFP_KERNEL);
+    // LOG_FUNCS(KERN_DEBUG, "%lu:%llu", vma, pte);
+    INIT_LIST_HEAD(&list_node->pg_list);
+    list_node->vma = vma;
+    list_node->pte = pte;
+    atomic_add(1, &total_extents);
+    return list_node;
+}
+
+void update_pg_extns(struct rb_extns *rb_node, unsigned long vma, unsigned long long pte) {
+    struct list_head *head = &rb_node->p_node;
+    struct list_extns *node = NULL;
+    struct list_head *pos = NULL;
+    struct list_head *tmp = NULL;
+
+    LOG_FUNCS(KERN_DEBUG, "%lu:%llu", vma, pte);
+
+    list_for_each_safe(pos, tmp, head) {
+        node = list_entry(pos, struct list_extns, pg_list);
+        if (node->vma != vma) continue;
+        node->pte = pte;
+        break;
+    }
+}
+
+void create_extents(struct list_extns *new_node) {
+    struct rb_extns *rb_node = kmalloc(sizeof(struct rb_extns), GFP_KERNEL);
+    // LOG_FUNCS(KERN_DEBUG, "%lu:%llu", new_node->vma, new_node->pte);
+    rb_node->count = 1;
+    INIT_LIST_HEAD(&rb_node->p_node);
+    list_add(&new_node->pg_list, &rb_node->p_node);
+    pg_insert(rb_node);
+    atomic_add(1, &pt_count);
+}
+
+struct rb_extns *should_join_front(unsigned long vma, unsigned long long pte) {
+    struct rb_extns *rb_node = NULL;
+    struct list_extns *node = NULL;
+
+    // LOG_FUNCS(KERN_DEBUG, "%lu:%llu", vma, pte);
+    vma += PAGE_SIZE;
+    pte += PAGE_SIZE;
+    rb_node = pg_search(&expg_root, vma);
+    if (rb_node == NULL) {
+        return NULL;
+    }
+
+    // LOG_FUNCS(KERN_DEBUG, "%lu:%llu", vma, pte);
+    node = list_first_entry(&rb_node->p_node, struct list_extns, pg_list);
+    if (node->vma == vma && node->pte == pte) {
+        // LOG_FUNCS(KERN_DEBUG, "%lu:%llu", node->vma, node->pte);
+        return rb_node;
+    }
+
+    return NULL;
+}
+
+struct rb_extns *should_join_back(unsigned long vma, unsigned long long pte) {
+    struct rb_extns *rb_node = NULL;
+    struct list_extns *node = NULL;
+
+    // LOG_FUNCS(KERN_DEBUG, "%lu:%llu", vma, pte);
+    vma -= PAGE_SIZE;
+    pte -= PAGE_SIZE;
+    rb_node = pg_search(&expg_root, vma);
+    if (rb_node == NULL) {
+        return NULL;
+    }
+
+    // LOG_FUNCS(KERN_DEBUG, "%lu:%llu", vma, pte);
+    node = list_last_entry(&rb_node->p_node, struct list_extns, pg_list);
+    if (node->vma == vma && node->pte == pte) {
+        // LOG_FUNCS(KERN_DEBUG, "%lu:%llu", node->vma, node->pte);
+        return rb_node;
+    }
+
+    return NULL;
+}
+
+void add_extents(unsigned long vma, unsigned long long pte) {
+    struct list_extns *new_node = NULL;
+    struct rb_extns *front = NULL;
+    struct rb_extns *back = NULL;
+
+    LOG_FUNCS(KERN_DEBUG, "%lu:%llu", vma, pte);
+    front = should_join_front(vma, pte);
+    back = should_join_back(vma, pte);
+    new_node = create_extn(vma, pte);
+
+    if (front) {
+        LOG_FUNCS(KERN_DEBUG, "list_add::%lu:%llu", vma, pte);
+
+        raw_spin_lock(&extents_lock);
+        list_add(&new_node->pg_list, &front->p_node); // add to the front: head->next is now node
+        front->count++;
+        raw_spin_unlock(&extents_lock);
+
+        if (back) {
+            LOG_FUNCS(KERN_DEBUG, "list_splice::%lu:%llu", vma, pte);
+
+            raw_spin_lock(&extents_lock);
+            list_splice(&front->p_node, back->p_node.prev); // join front to end of back
+            back->count += front->count;
+            rb_erase(&front->pg_tree, &expg_root); // front has been removed, so better to remove this
+            atomic_sub(1, &pt_count);
+            raw_spin_unlock(&extents_lock);
+
+            kfree(front);
+        }
+    } else if (back) {
+        LOG_FUNCS(KERN_DEBUG, "list_add_tail::%lu:%llu", vma, pte);
+
+        raw_spin_lock(&extents_lock);
+        list_add_tail(&new_node->pg_list, &back->p_node); // add to the rear: head->prev is now node
+        back->count++;
+        raw_spin_unlock(&extents_lock);
+    } else {
+        LOG_FUNCS(KERN_DEBUG, "create_extents::%lu:%llu", vma, pte);
+
+        create_extents(new_node);
+    }
+}
+
+void handle_extents(unsigned long vma, unsigned long long pte) {
+    struct rb_extns *node = NULL;
+    pid_t pid = current->tgid;
+
+    if (pid ==  do_extents_pid) {
+        LOG_FUNCS(KERN_DEBUG, "%lu:%llu", vma, pte);
+
+        node = pg_search(&expg_root, vma);
+        if (node)
+            update_pg_extns(node, vma, pte);
+        else
+            add_extents(vma, pte);
+    }
+}
+EXPORT_SYMBOL(handle_extents);
+
+SYSCALL_DEFINE0(enable_extents) {
+    pid_t pid;
+    if (do_extents_pid != -1) {
+        return -EFAULT;
+    }
+
+    // since all child process are part of the same thread group, better to use tgid here
+    pid = current->tgid;
+    LOG_FUNCS(KERN_ALERT "%d", pid);
+    do_extents_pid = pid;
+    atomic_set(&pt_count, 0);
+    atomic_set(&total_extents, 0);
+    return 0;
+}
+
+SYSCALL_DEFINE0(disable_extents) {
+    // since all child process are part of the same thread group, better to use tgid here
+    pid_t pid = current->tgid;
+
+    // if your program quits prematurely, reboot your system to get this up and running again
+    if (pid == do_extents_pid) {
+        LOG_FUNCS(KERN_ALERT "%d had %d extents and %d pages", pid, pt_count.counter, total_extents.counter);
+
+        do_extents_pid = -1;
+        atomic_set(&pt_count, 0);
+        atomic_set(&total_extents, 0);
+        // print_pg_tree();
+        free_pg_tree();
+    } else {
+        return -EFAULT;
+    }
+    return 0;
+}
+
+SYSCALL_DEFINE2(get_ex_count, int *, extns, int *, pages) {
+    if (copy_to_user(extns, &pt_count.counter, sizeof(int))) {
+        return -EFAULT;
+    }
+
+    if (copy_to_user(pages, &total_extents.counter, sizeof(int))) {
+        return -EFAULT;
+    }
+    return 0;
+}
+
+// helper function to print some details
+// better to retain this if i wish to print more stuff in the future...
+SYSCALL_DEFINE0(print_ex_pid) {
+    // https://ypl.coffee/parent-and-real-parent-in-task-struct/
+    printk("%s: pid: %d\n", __func__, current->pid);
+    printk("%s: tgid: %d\n", __func__, current->tgid);
+    printk("%s: peid: %lld\n", __func__, current->parent_exec_id);
+    printk("%s: seid: %lld\n", __func__, current->self_exec_id);
+    printk("%s: current->pid: %d\n", __func__, task_pid_nr(current));
+    printk("%s: current->pid_nr: %d\n", __func__, pid_nr(task_pid(current)));
+    printk("%s: current->real_parent->pid: %d\n", __func__,
+           task_pid_nr(current->real_parent));
+    printk("%s: current->real_parent->pid_nr: %d\n", __func__,
+           pid_nr(task_pid(current->real_parent)));
+    printk("%s: current->parent->pid: %d\n", __func__,
+           task_pid_nr(current->parent));
+    printk("%s: current->real_parent->pid_nr: %d\n", __func__,
+           pid_nr(task_pid(current->parent)));
+    return 0;
+}
