--- /dev/null	2025-04-10 00:28:07.172000538 -0600
+++ ../project2/linux-5.15.0/mm/my_extent.c	2025-04-10 11:55:21.079773939 -0600
@@ -0,0 +1,165 @@
+#include <linux/kernel.h>
+#include <linux/syscalls.h>
+#include <linux/my_extent.h>
+#include <linux/printk.h>
+
+pid_t do_extents_pid = -1;
+EXPORT_SYMBOL(do_extents_pid);
+
+// my rb root tree for page extns
+struct rb_root expg_root = RB_ROOT;
+size_t pt_count;
+
+void free_pg_list(struct list_head *head) {
+    struct list_extns *curr, *node;
+    list_for_each_entry_safe(curr, node, head, pg_list) {
+        printk(KERN_INFO "%lu:%lld", curr->pte, curr->vma);
+        list_del(&curr->pg_list);
+        kfree(curr);
+
+        if (node) printk(KERN_INFO ",");
+    }
+    printk(KERN_INFO "\n");
+}
+
+void free_pg_tree(void) {
+    struct rb_node *root;
+    int iter = 0;
+    for (root = rb_first(&expg_root); root;) {
+        struct rb_node *cursor = rb_next(root);
+        struct rb_extns *node = rb_entry_safe(root, struct rb_extns, pg_tree);
+        if (node) {
+            printk(KERN_INFO "%d:%d::", iter, node->count);
+            free_pg_list(&node->p_node);
+            rb_erase(&node->pg_tree, &expg_root);
+            kfree(node);
+        }
+        root = cursor;
+        iter++;
+    }
+}
+
+int compare_pg(struct rb_node **cursor, struct rb_extns *node, unsigned long long pte) {
+    struct list_extns *head = list_first_entry_or_null(&node->p_node, struct list_extns, pg_list);
+    struct list_extns *tail = list_last_entry(&node->p_node, struct list_extns, pg_list);
+
+    if (head == NULL) {
+        printk(KERN_CRIT "Invalid entry while adding pte %lu\n", pte);
+        return -1; // invalid entry!!
+    }
+
+    if (head->pte > pte)
+        cursor = &((*cursor)->rb_left);
+    else if (tail->pte < pte)
+        cursor = &((*cursor)->rb_right);
+    else // most likely within our list of extents
+        return 0;
+
+    return 1; // continue searching
+}
+
+struct rb_extns *pg_search(struct rb_root *root, unsigned long vma, unsigned long long pte) {
+    struct rb_node *cursor = root->rb_node;
+    while(cursor) {
+        struct rb_extns *node = container_of(cursor, struct rb_extns, pg_tree);
+        int result = compare_pg(&cursor, node, pte);
+
+        if (result == -1)
+            return NULL;
+        else if (result == 0)
+            return node;
+    }
+    return NULL;
+}
+
+int pg_insert(struct rb_root *root, struct rb_extns *data) {
+    struct list_extns *head = list_first_entry_or_null(&data->p_node, struct list_extns, pg_list);
+    if (head == NULL) return 0;
+
+    struct rb_node **cursor = &(root->rb_node), *parent = NULL;
+    while(*cursor) {
+        struct rb_extns *node = container_of(*cursor, struct rb_extns, pg_tree);
+        parent = *cursor;
+
+        if (compare_pg(cursor, node, head->pte) != 1) return 0;
+    }
+
+    rb_link_node(&data->pg_tree, parent, cursor);
+    rb_insert_color(&data->pg_tree, root);
+    return 1;
+}
+
+struct list_extns *create_extn(unsigned long vma, unsigned long long pte) {
+    struct list_extns *list_node = kmalloc(sizeof(struct list_extns), GFP_KERNEL);
+    list_node->pte = pte;
+    list_node->vma = vma;
+    return list_node;
+}
+
+void update_pg_extns(struct rb_extns *rb_node, unsigned long vma, unsigned long long pte) {
+    struct list_head *head = &rb_node->p_node;
+    struct list_extns *node = list_first_entry(head, struct list_extns, pg_list);
+    if (node->pte > pte) {
+        list_add_tail(&(create_extn(vma, pte))->pg_list, head);
+        rb_node->count++;
+        return;
+    }
+
+    node = list_last_entry(head, struct list_extns, pg_list);
+    if (node->pte < pte) {
+        list_add(&(create_extn(vma, pte))->pg_list, head->prev);
+        rb_node->count++;
+        return;
+    }
+
+    struct list_head *pos = NULL;
+    list_for_each(pos, head) {
+        node = list_entry(pos, struct list_extns, pg_list);
+        if (node->pte != pte) continue;
+        node->vma = vma;
+        return;
+    }
+}
+
+void add_extents(unsigned long vma, unsigned long long pte) {
+    struct rb_extns *rb_node = kmalloc(sizeof(struct rb_extns), GFP_KERNEL);
+    rb_node->count = 1;
+    INIT_LIST_HEAD(&rb_node->p_node);
+
+
+    list_add(&create_extn(vma, pte)->pg_list, &rb_node->p_node);
+    pg_insert(&expg_root, rb_node);
+    pt_count++;
+}
+
+void handle_extents(unsigned long vma, unsigned long long pte) {
+    pid_t pid = task_pid_nr(current);
+    if (pid ==  do_extents_pid) {
+        // currently only updates existing nodes, need to handle the other part too
+        struct rb_extns *node = pg_search(&expg_root, vma, pte);
+        if (node)
+            update_pg_extns(node, vma, pte);
+        else
+            add_extents(vma, pte);
+    }
+}
+EXPORT_SYMBOL(handle_extents);
+
+SYSCALL_DEFINE0(enable_extents)
+{
+    pid_t pid = task_pid_nr(current);
+    do_extents_pid = pid;
+    pt_count = 0;
+    return 0;
+}
+
+SYSCALL_DEFINE0(disable_extents)
+{
+    pid_t pid = task_pid_nr(current);
+    if (pid == do_extents_pid) {
+        do_extents_pid = -1;
+        pt_count = 0;
+        free_pg_tree();
+    }
+    return 0;
+}
